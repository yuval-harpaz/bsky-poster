{"version":3,"file":"aturi_validation.js","sourceRoot":"","sources":["../src/aturi_validation.ts"],"names":[],"mappings":"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","sourcesContent":["import { AtIdentifierString, ensureValidAtIdentifier } from './at-identifier.js'\nimport { ensureValidDidRegex } from './did.js'\nimport { ensureValidHandleRegex } from './handle.js'\nimport { NsidString, isValidNsid } from './nsid.js'\n\nexport type AtUriString =\n  | `at://${AtIdentifierString}`\n  | `at://${AtIdentifierString}/${NsidString}`\n  | `at://${AtIdentifierString}/${NsidString}/${string}`\n\n// Human-readable constraints on ATURI:\n//   - following regular URLs, a 8KByte hard total length limit\n//   - follows ATURI docs on website\n//      - all ASCII characters, no whitespace. non-ASCII could be URL-encoded\n//      - starts \"at://\"\n//      - \"authority\" is a valid DID or a valid handle\n//      - optionally, follow \"authority\" with \"/\" and valid NSID as start of path\n//      - optionally, if NSID given, follow that with \"/\" and rkey\n//      - rkey path component can include URL-encoded (\"percent encoded\"), or:\n//          ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\" / \":\" / \"@\" / \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n//          [a-zA-Z0-9._~:@!$&'\\(\\)*+,;=-]\n//      - rkey must have at least one char\n//      - regardless of path component, a fragment can follow  as \"#\" and then a JSON pointer (RFC-6901)\n\nexport function ensureValidAtUri(input: string): asserts input is AtUriString {\n  const fragmentIndex = input.indexOf('#')\n  if (fragmentIndex !== -1) {\n    if (input.charCodeAt(fragmentIndex + 1) !== 47) {\n      throw new Error('ATURI fragment must be non-empty and start with slash')\n    }\n    if (input.includes('#', fragmentIndex + 1)) {\n      throw new Error('ATURI can have at most one \"#\", separating fragment out')\n    }\n\n    // NOTE: enforcing *some* checks here for sanity. Eg, at least no whitespace\n    const fragment = input.slice(fragmentIndex + 1)\n    if (!/^\\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\\]/-]*$/.test(fragment)) {\n      throw new Error('Disallowed characters in ATURI fragment (ASCII)')\n    }\n  }\n\n  const uri = fragmentIndex === -1 ? input : input.slice(0, fragmentIndex)\n\n  if (uri.length > 8 * 1024) {\n    throw new Error('ATURI is far too long')\n  }\n\n  if (!uri.startsWith('at://')) {\n    throw new Error('ATURI must start with \"at://\"')\n  }\n\n  // check that all chars are boring ASCII\n  if (!/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(uri)) {\n    throw new Error('Disallowed characters in ATURI (ASCII)')\n  }\n\n  const authorityEnd = uri.indexOf('/', 5)\n  const authority =\n    authorityEnd === -1 ? uri.slice(5) : uri.slice(5, authorityEnd)\n  try {\n    ensureValidAtIdentifier(authority)\n  } catch (cause) {\n    throw new Error('ATURI authority must be a valid handle or DID', { cause })\n  }\n\n  const collectionStart = authorityEnd === -1 ? -1 : authorityEnd + 1\n  const collectionEnd =\n    collectionStart === -1 ? -1 : uri.indexOf('/', collectionStart)\n\n  if (collectionStart !== -1) {\n    const collection =\n      collectionEnd === -1\n        ? uri.slice(collectionStart)\n        : uri.slice(collectionStart, collectionEnd)\n\n    if (collection.length === 0) {\n      throw new Error(\n        'ATURI can not have a slash after authority without a path segment',\n      )\n    }\n    if (!isValidNsid(collection)) {\n      throw new Error(\n        'ATURI requires first path segment (if supplied) to be valid NSID',\n      )\n    }\n  }\n\n  const recordKeyStart = collectionEnd === -1 ? -1 : collectionEnd + 1\n  const recordKeyEnd =\n    recordKeyStart === -1 ? -1 : uri.indexOf('/', recordKeyStart)\n\n  if (recordKeyStart !== -1) {\n    if (recordKeyStart === uri.length) {\n      throw new Error(\n        'ATURI can not have a slash after collection, unless record key is provided',\n      )\n    }\n    // would validate rkey here, but there are basically no constraints!\n  }\n\n  if (recordKeyEnd !== -1) {\n    throw new Error(\n      'ATURI path can have at most two parts, and no trailing slash',\n    )\n  }\n}\n\nexport function ensureValidAtUriRegex(uri: string): asserts uri is AtUriString {\n  // simple regex to enforce most constraints via just regex and length.\n  // hand wrote this regex based on above constraints. whew!\n  const aturiRegex =\n    /^at:\\/\\/(?<authority>[a-zA-Z0-9._:%-]+)(\\/(?<collection>[a-zA-Z0-9-.]+)(\\/(?<rkey>[a-zA-Z0-9._~:@!$&%')(*+,;=-]+))?)?(#(?<fragment>\\/[a-zA-Z0-9._~:@!$&%')(*+,;=\\-[\\]/\\\\]*))?$/\n  const rm = uri.match(aturiRegex)\n  if (!rm || !rm.groups) {\n    throw new Error(\"ATURI didn't validate via regex\")\n  }\n  const groups = rm.groups\n\n  try {\n    ensureValidHandleRegex(groups.authority)\n  } catch {\n    try {\n      ensureValidDidRegex(groups.authority)\n    } catch {\n      throw new Error('ATURI authority must be a valid handle or DID')\n    }\n  }\n\n  if (groups.collection && !isValidNsid(groups.collection)) {\n    throw new Error('ATURI collection path segment must be a valid NSID')\n  }\n\n  if (uri.length > 8 * 1024) {\n    throw new Error('ATURI is far too long')\n  }\n}\n"]}