{"version":3,"file":"lexicons.js","sourceRoot":"","sources":["../src/lexicons.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  InvalidLexiconError,\n  LexRecord,\n  LexUserType,\n  LexiconDefNotFoundError,\n  LexiconDoc,\n  ValidationError,\n  ValidationResult,\n  isObj,\n} from './types'\nimport { toLexUri } from './util'\nimport {\n  assertValidRecord,\n  assertValidXrpcInput,\n  assertValidXrpcMessage,\n  assertValidXrpcOutput,\n  assertValidXrpcParams,\n} from './validation'\nimport { object as validateObject } from './validators/complex'\n\n/**\n * A collection of compiled lexicons.\n */\nexport class Lexicons implements Iterable<LexiconDoc> {\n  docs: Map<string, LexiconDoc> = new Map()\n  defs: Map<string, LexUserType> = new Map()\n\n  constructor(docs?: Iterable<LexiconDoc>) {\n    if (docs) {\n      for (const doc of docs) {\n        this.add(doc)\n      }\n    }\n  }\n\n  /**\n   * @example clone a lexicon:\n   * ```ts\n   * const clone = new Lexicons(originalLexicon)\n   * ```\n   *\n   * @example get docs array:\n   * ```ts\n   * const docs = Array.from(lexicons)\n   * ```\n   */\n  [Symbol.iterator](): Iterator<LexiconDoc> {\n    return this.docs.values()\n  }\n\n  /**\n   * Add a lexicon doc.\n   */\n  add(doc: LexiconDoc): void {\n    const uri = toLexUri(doc.id)\n    if (this.docs.has(uri)) {\n      throw new Error(`${uri} has already been registered`)\n    }\n\n    // WARNING\n    // mutates the object\n    // -prf\n    resolveRefUris(doc, uri)\n\n    this.docs.set(uri, doc)\n    for (const [defUri, def] of iterDefs(doc)) {\n      this.defs.set(defUri, def)\n    }\n  }\n\n  /**\n   * Remove a lexicon doc.\n   */\n  remove(uri: string) {\n    uri = toLexUri(uri)\n    const doc = this.docs.get(uri)\n    if (!doc) {\n      throw new Error(`Unable to remove \"${uri}\": does not exist`)\n    }\n    for (const [defUri, _def] of iterDefs(doc)) {\n      this.defs.delete(defUri)\n    }\n    this.docs.delete(uri)\n  }\n\n  /**\n   * Get a lexicon doc.\n   */\n  get(uri: string): LexiconDoc | undefined {\n    uri = toLexUri(uri)\n    return this.docs.get(uri)\n  }\n\n  /**\n   * Get a definition.\n   */\n  getDef(uri: string): LexUserType | undefined {\n    uri = toLexUri(uri)\n    return this.defs.get(uri)\n  }\n\n  /**\n   * Get a def, throw if not found. Throws on not found.\n   */\n  getDefOrThrow<T extends LexUserType['type'] = LexUserType['type']>(\n    uri: string,\n    types?: readonly T[],\n  ): Extract<LexUserType, { type: T }>\n  getDefOrThrow(\n    uri: string,\n    types?: readonly LexUserType['type'][],\n  ): LexUserType {\n    const def = this.getDef(uri)\n    if (!def) {\n      throw new LexiconDefNotFoundError(`Lexicon not found: ${uri}`)\n    }\n    if (types && !types.includes(def.type)) {\n      throw new InvalidLexiconError(\n        `Not a ${types.join(' or ')} lexicon: ${uri}`,\n      )\n    }\n    return def\n  }\n\n  /**\n   * Validate a record or object.\n   */\n  validate(lexUri: string, value: unknown): ValidationResult {\n    if (!isObj(value)) {\n      throw new ValidationError(`Value must be an object`)\n    }\n\n    const lexUriNormalized = toLexUri(lexUri)\n    const def = this.getDefOrThrow(lexUriNormalized, ['record', 'object'])\n\n    if (def.type === 'record') {\n      return validateObject(this, 'Record', def.record, value)\n    } else if (def.type === 'object') {\n      return validateObject(this, 'Object', def, value)\n    } else {\n      // shouldn't happen\n      throw new InvalidLexiconError('Definition must be a record or object')\n    }\n  }\n\n  /**\n   * Validate a record and throw on any error.\n   */\n  assertValidRecord(lexUri: string, value: unknown) {\n    if (!isObj(value)) {\n      throw new ValidationError(`Record must be an object`)\n    }\n    if (!('$type' in value)) {\n      throw new ValidationError(`Record/$type must be a string`)\n    }\n    const { $type } = value\n    if (typeof $type !== 'string') {\n      throw new ValidationError(`Record/$type must be a string`)\n    }\n\n    const lexUriNormalized = toLexUri(lexUri)\n    if (toLexUri($type) !== lexUriNormalized) {\n      throw new ValidationError(\n        `Invalid $type: must be ${lexUriNormalized}, got ${$type}`,\n      )\n    }\n\n    const def = this.getDefOrThrow(lexUriNormalized, ['record'])\n    return assertValidRecord(this, def as LexRecord, value)\n  }\n\n  /**\n   * Validate xrpc query params and throw on any error.\n   */\n  assertValidXrpcParams(lexUri: string, value: unknown) {\n    lexUri = toLexUri(lexUri)\n    const def = this.getDefOrThrow(lexUri, [\n      'query',\n      'procedure',\n      'subscription',\n    ])\n    return assertValidXrpcParams(this, def, value)\n  }\n\n  /**\n   * Validate xrpc input body and throw on any error.\n   */\n  assertValidXrpcInput(lexUri: string, value: unknown) {\n    lexUri = toLexUri(lexUri)\n    const def = this.getDefOrThrow(lexUri, ['procedure'])\n    return assertValidXrpcInput(this, def, value)\n  }\n\n  /**\n   * Validate xrpc output body and throw on any error.\n   */\n  assertValidXrpcOutput(lexUri: string, value: unknown) {\n    lexUri = toLexUri(lexUri)\n    const def = this.getDefOrThrow(lexUri, ['query', 'procedure'])\n    return assertValidXrpcOutput(this, def, value)\n  }\n\n  /**\n   * Validate xrpc subscription message and throw on any error.\n   */\n  assertValidXrpcMessage<T = unknown>(lexUri: string, value: unknown): T {\n    lexUri = toLexUri(lexUri)\n    const def = this.getDefOrThrow(lexUri, ['subscription'])\n    return assertValidXrpcMessage(this, def, value) as T\n  }\n\n  /**\n   * Resolve a lex uri given a ref\n   */\n  resolveLexUri(lexUri: string, ref: string) {\n    lexUri = toLexUri(lexUri)\n    return toLexUri(ref, lexUri)\n  }\n}\n\nfunction* iterDefs(doc: LexiconDoc): Generator<[string, LexUserType]> {\n  for (const defId in doc.defs) {\n    yield [`lex:${doc.id}#${defId}`, doc.defs[defId]]\n    if (defId === 'main') {\n      yield [`lex:${doc.id}`, doc.defs[defId]]\n    }\n  }\n}\n\n// WARNING\n// this method mutates objects\n// -prf\nfunction resolveRefUris(obj: any, baseUri: string): any {\n  for (const k in obj) {\n    if (obj.type === 'ref') {\n      obj.ref = toLexUri(obj.ref, baseUri)\n    } else if (obj.type === 'union') {\n      obj.refs = obj.refs.map((ref) => toLexUri(ref, baseUri))\n    } else if (Array.isArray(obj[k])) {\n      obj[k] = obj[k].map((item: any) => {\n        if (typeof item === 'string') {\n          return item.startsWith('#') ? toLexUri(item, baseUri) : item\n        } else if (item && typeof item === 'object') {\n          return resolveRefUris(item, baseUri)\n        }\n        return item\n      })\n    } else if (obj[k] && typeof obj[k] === 'object') {\n      obj[k] = resolveRefUris(obj[k], baseUri)\n    }\n  }\n  return obj\n}\n"]}