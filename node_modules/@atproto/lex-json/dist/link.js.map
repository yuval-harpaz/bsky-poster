{"version":3,"file":"link.js","sourceRoot":"","sources":["../src/link.ts"],"names":[],"mappings":";;AAGA,oCA6BC;AAED,sCAEC;AApCD,gDAAiD;AAGjD,SAAgB,YAAY,CAAC,KAA2B;IACtD,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC,OAAO,IAAI,KAAK,CAAC,EAAE,CAAC;QAClC,OAAO,SAAS,CAAA;IAClB,CAAC;IAED,KAAK,MAAM,GAAG,IAAI,KAAK,EAAE,CAAC;QACxB,IAAI,GAAG,KAAK,OAAO,EAAE,CAAC;YACpB,OAAO,SAAS,CAAA;QAClB,CAAC;IACH,CAAC;IAED,IAAI,OAAO,KAAK,CAAC,KAAK,KAAK,QAAQ,EAAE,CAAC;QACpC,MAAM,IAAI,SAAS,CAAC,2CAA2C,CAAC,CAAA;IAClE,CAAC;IAED,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QAC7B,MAAM,IAAI,SAAS,CAAC,qCAAqC,CAAC,CAAA;IAC5D,CAAC;IAED,yDAAyD;IACzD,IAAI,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,EAAE,CAAC;QAC9B,MAAM,IAAI,SAAS,CAAC,iCAAiC,CAAC,CAAA;IACxD,CAAC;IAED,IAAI,CAAC;QACH,OAAO,IAAA,mBAAQ,EAAC,KAAK,CAAC,KAAK,CAAC,CAAA;IAC9B,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,MAAM,IAAI,SAAS,CAAC,6BAA6B,EAAE,EAAE,KAAK,EAAE,CAAC,CAAA;IAC/D,CAAC;AACH,CAAC;AAED,SAAgB,aAAa,CAAC,GAAQ;IACpC,OAAO,EAAE,KAAK,EAAE,GAAG,CAAC,QAAQ,EAAE,EAAE,CAAA;AAClC,CAAC","sourcesContent":["import { Cid, parseCid } from '@atproto/lex-data'\nimport { JsonValue } from './json.js'\n\nexport function parseLexLink(input?: { $link?: unknown }): Cid | undefined {\n  if (!input || !('$link' in input)) {\n    return undefined\n  }\n\n  for (const key in input) {\n    if (key !== '$link') {\n      return undefined\n    }\n  }\n\n  if (typeof input.$link !== 'string') {\n    throw new TypeError('$link must be a base32-encoded CID string')\n  }\n\n  if (input.$link.length === 0) {\n    throw new TypeError('CID string in $link cannot be empty')\n  }\n\n  // Arbitrary limit to prevent DoS via extremely long CIDs\n  if (input.$link.length > 2048) {\n    throw new TypeError('CID string in $link is too long')\n  }\n\n  try {\n    return parseCid(input.$link)\n  } catch (cause) {\n    throw new TypeError('Invalid CID string in $link', { cause })\n  }\n}\n\nexport function encodeLexLink(cid: Cid): JsonValue {\n  return { $link: cid.toString() }\n}\n"]}