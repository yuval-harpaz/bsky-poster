{"version":3,"file":"retry.js","sourceRoot":"","sources":["../src/retry.ts"],"names":[],"mappings":";;AAOA,sBA2BC;AAED,0CAGC;AAGD,8BAIC;AA9CD,iCAA6B;AAOtB,KAAK,UAAU,KAAK,CACzB,EAAoB,EACpB,OAEI,EAAE;IAEN,MAAM,EAAE,UAAU,GAAG,CAAC,EAAE,SAAS,GAAG,GAAG,EAAE,CAAC,IAAI,EAAE,SAAS,GAAG,SAAS,EAAE,GAAG,IAAI,CAAA;IAC9E,IAAI,OAAO,GAAG,CAAC,CAAA;IACf,IAAI,SAAkB,CAAA;IACtB,OAAO,CAAC,SAAS,EAAE,CAAC;QAClB,IAAI,CAAC;YACH,OAAO,MAAM,EAAE,EAAE,CAAA;QACnB,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACb,MAAM,MAAM,GAAG,SAAS,CAAC,OAAO,CAAC,CAAA;YACjC,MAAM,SAAS,GACb,OAAO,GAAG,UAAU,IAAI,MAAM,KAAK,IAAI,IAAI,SAAS,CAAC,GAAG,CAAC,CAAA;YAC3D,IAAI,SAAS,EAAE,CAAC;gBACd,OAAO,IAAI,CAAC,CAAA;gBACZ,IAAI,MAAM,KAAK,CAAC,EAAE,CAAC;oBACjB,MAAM,IAAA,WAAI,EAAC,MAAM,CAAC,CAAA;gBACpB,CAAC;YACH,CAAC;iBAAM,CAAC;gBACN,SAAS,GAAG,GAAG,CAAA;YACjB,CAAC;QACH,CAAC;IACH,CAAC;IACD,MAAM,SAAS,CAAA;AACjB,CAAC;AAED,SAAgB,eAAe,CAAC,SAAoC;IAClE,OAAO,KAAK,EAAK,EAAoB,EAAE,IAAmB,EAAE,EAAE,CAC5D,KAAK,CAAC,EAAE,EAAE,EAAE,GAAG,IAAI,EAAE,SAAS,EAAE,CAAC,CAAA;AACrC,CAAC;AAED,2FAA2F;AAC3F,SAAgB,SAAS,CAAC,CAAS,EAAE,UAAU,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI;IAC/D,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,UAAU,CAAA;IACjD,MAAM,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE,GAAG,CAAC,CAAA;IACvC,OAAO,MAAM,CAAC,EAAE,CAAC,CAAA;AACnB,CAAC;AAED,kCAAkC;AAClC,SAAS,MAAM,CAAC,KAAa;IAC3B,MAAM,KAAK,GAAG,KAAK,GAAG,IAAI,CAAA;IAC1B,OAAO,KAAK,GAAG,WAAW,CAAC,CAAC,KAAK,EAAE,KAAK,CAAC,CAAA;AAC3C,CAAC;AAED,SAAS,WAAW,CAAC,IAAY,EAAE,EAAU;IAC3C,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE,GAAG,IAAI,CAAC,CAAA;IACxC,OAAO,IAAI,GAAG,IAAI,CAAA;AACpB,CAAC","sourcesContent":["import { wait } from './util'\n\nexport type RetryOptions = {\n  maxRetries?: number\n  getWaitMs?: (n: number) => number | null\n}\n\nexport async function retry<T>(\n  fn: () => Promise<T>,\n  opts: RetryOptions & {\n    retryable?: (err: unknown) => boolean\n  } = {},\n): Promise<T> {\n  const { maxRetries = 3, retryable = () => true, getWaitMs = backoffMs } = opts\n  let retries = 0\n  let doneError: unknown\n  while (!doneError) {\n    try {\n      return await fn()\n    } catch (err) {\n      const waitMs = getWaitMs(retries)\n      const willRetry =\n        retries < maxRetries && waitMs !== null && retryable(err)\n      if (willRetry) {\n        retries += 1\n        if (waitMs !== 0) {\n          await wait(waitMs)\n        }\n      } else {\n        doneError = err\n      }\n    }\n  }\n  throw doneError\n}\n\nexport function createRetryable(retryable: (err: unknown) => boolean) {\n  return async <T>(fn: () => Promise<T>, opts?: RetryOptions) =>\n    retry(fn, { ...opts, retryable })\n}\n\n// Waits exponential backoff with max and jitter: ~100, ~200, ~400, ~800, ~1000, ~1000, ...\nexport function backoffMs(n: number, multiplier = 100, max = 1000) {\n  const exponentialMs = Math.pow(2, n) * multiplier\n  const ms = Math.min(exponentialMs, max)\n  return jitter(ms)\n}\n\n// Adds randomness +/-15% of value\nfunction jitter(value: number) {\n  const delta = value * 0.15\n  return value + randomRange(-delta, delta)\n}\n\nfunction randomRange(from: number, to: number) {\n  const rand = Math.random() * (to - from)\n  return rand + from\n}\n"]}