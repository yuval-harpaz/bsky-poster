"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isLexMap = isLexMap;
exports.isLexArray = isLexArray;
exports.isLexScalar = isLexScalar;
exports.isLexValue = isLexValue;
exports.isTypedLexMap = isTypedLexMap;
const cid_js_1 = require("./cid.js");
const object_js_1 = require("./object.js");
function isLexMap(value) {
    return (0, object_js_1.isPlainObject)(value) && Object.values(value).every(isLexValue);
}
function isLexArray(value) {
    return Array.isArray(value) && value.every(isLexValue);
}
function isLexScalar(value) {
    switch (typeof value) {
        case 'object':
            return value === null || value instanceof Uint8Array || (0, cid_js_1.isCid)(value);
        case 'string':
        case 'boolean':
            return true;
        case 'number':
            if (Number.isInteger(value))
                return true;
        // fallthrough
        default:
            return false;
    }
}
function isLexValue(value) {
    // Using a stack to avoid recursion depth issues.
    const stack = [value];
    // Cyclic structures are not valid LexValues as they cannot be serialized to
    // JSON or CBOR. This also allows us to avoid infinite loops when traversing
    // the structure.
    const visited = new Set();
    do {
        const value = stack.pop();
        // Optimization: we are not using `isLexScalar` here to avoid extra function
        // calls, and to avoid computing `typeof value` multiple times.
        switch (typeof value) {
            case 'object':
                if (value === null) {
                    // LexScalar
                }
                else if ((0, object_js_1.isPlainProto)(value)) {
                    if (visited.has(value))
                        return false;
                    visited.add(value);
                    stack.push(...Object.values(value));
                }
                else if (Array.isArray(value)) {
                    if (visited.has(value))
                        return false;
                    visited.add(value);
                    stack.push(...value);
                }
                else if (value instanceof Uint8Array || (0, cid_js_1.isCid)(value)) {
                    // LexScalar
                }
                else {
                    return false;
                }
                break;
            case 'string':
            case 'boolean':
                break;
            case 'number':
                if (Number.isInteger(value))
                    break;
            // fallthrough
            default:
                return false;
        }
    } while (stack.length > 0);
    // Optimization: ease GC's work
    visited.clear();
    return true;
}
function isTypedLexMap(value) {
    return (isLexMap(value) && typeof value.$type === 'string' && value.$type.length > 0);
}
//# sourceMappingURL=lex.js.map