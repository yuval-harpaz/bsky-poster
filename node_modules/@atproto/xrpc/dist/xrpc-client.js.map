{"version":3,"file":"xrpc-client.js","sourceRoot":"","sources":["../src/xrpc-client.ts"],"names":[],"mappings":";;;AAAA,8CAAwE;AACxE,mDAKwB;AACxB,mCASgB;AAChB,iCAQe;AAEf,MAAa,UAAU;IAKrB,YACE,gBAAyE;IACzE,8DAA8D;IAC9D,2DAA2D;IAC3D,GAAoC;QAR7B;;;;;WAA0B;QAC1B;;;;mBAAU,IAAI,GAAG,EAAmC;WAAA;QACpD;;;;;WAAa;QAQpB,IAAI,CAAC,YAAY,GAAG,IAAA,iCAAiB,EAAC,gBAAgB,CAAC,CAAA;QAEvD,IAAI,CAAC,GAAG,GAAG,GAAG,YAAY,kBAAQ,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,kBAAQ,CAAC,GAAG,CAAC,CAAA;IAC9D,CAAC;IAED,SAAS,CAAC,GAAW,EAAE,KAA8B;QACnD,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,EAAE,EAAE,KAAK,CAAC,CAAA;IAC5C,CAAC;IAED,WAAW,CAAC,GAAW;QACrB,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAA;IACxC,CAAC;IAED,YAAY;QACV,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAA;IACtB,CAAC;IAED,KAAK,CAAC,IAAI,CACR,UAAkB,EAClB,MAAoB,EACpB,IAAc,EACd,IAAkB;QAElB,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,aAAa,CAAC,UAAU,CAAC,CAAA;QAC9C,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,KAAK,OAAO,IAAI,GAAG,CAAC,IAAI,KAAK,WAAW,CAAC,EAAE,CAAC;YAC/D,MAAM,IAAI,SAAS,CACjB,oBAAoB,UAAU,iCAAiC,CAChE,CAAA;QACH,CAAC;QAED,sDAAsD;QACtD,qDAAqD;QACrD,4BAA4B;QAC5B,oDAAoD;QACpD,IAAI;QAEJ,MAAM,MAAM,GAAG,IAAA,6BAAsB,EAAC,UAAU,EAAE,GAAG,EAAE,MAAM,CAAC,CAAA;QAC9D,MAAM,SAAS,GAAG,IAAA,gCAAyB,EAAC,GAAG,CAAC,CAAA;QAChD,MAAM,UAAU,GAAG,IAAA,iCAA0B,EAAC,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,CAAA;QAC9D,MAAM,OAAO,GAAG,IAAA,2BAAoB,EAAC,UAAU,EAAE,IAAI,CAAC,CAAA;QAEtD,2EAA2E;QAC3E,uEAAuE;QACvE,MAAM,IAAI,GAAqC;YAC7C,MAAM,EAAE,SAAS;YACjB,OAAO,EAAE,IAAA,qBAAc,EAAC,UAAU,EAAE,IAAI,CAAC,OAAO,CAAC;YACjD,IAAI,EAAE,OAAO;YACb,MAAM,EAAE,MAAM;YACd,QAAQ,EAAE,QAAQ;YAClB,MAAM,EAAE,IAAI,EAAE,MAAM;SACrB,CAAA;QAED,IAAI,CAAC;YACH,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,SAAS,EAAE,MAAM,EAAE,IAAI,CAAC,CAAA;YAEtE,MAAM,SAAS,GAAG,QAAQ,CAAC,MAAM,CAAA;YACjC,MAAM,UAAU,GAAG,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAA;YACjE,MAAM,YAAY,GAAG,MAAM,QAAQ,CAAC,WAAW,EAAE,CAAA;YACjD,MAAM,OAAO,GAAG,IAAA,4BAAqB,EACnC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,EACpC,YAAY,CACb,CAAA;YAED,MAAM,OAAO,GAAG,IAAA,8BAAsB,EAAC,SAAS,CAAC,CAAA;YACjD,IAAI,OAAO,KAAK,oBAAY,CAAC,OAAO,EAAE,CAAC;gBACrC,MAAM,EAAE,KAAK,GAAG,SAAS,EAAE,OAAO,GAAG,SAAS,EAAE,GAC9C,OAAO,IAAI,IAAA,0BAAmB,EAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAA;gBACxD,MAAM,IAAI,iBAAS,CAAC,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,UAAU,CAAC,CAAA;YAC1D,CAAC;YAED,IAAI,CAAC;gBACH,IAAI,CAAC,GAAG,CAAC,qBAAqB,CAAC,UAAU,EAAE,OAAO,CAAC,CAAA;YACrD,CAAC;YAAC,OAAO,CAAU,EAAE,CAAC;gBACpB,IAAI,CAAC,YAAY,yBAAe,EAAE,CAAC;oBACjC,MAAM,IAAI,gCAAwB,CAAC,UAAU,EAAE,CAAC,EAAE,OAAO,CAAC,CAAA;gBAC5D,CAAC;gBAED,MAAM,CAAC,CAAA;YACT,CAAC;YAED,OAAO,IAAI,oBAAY,CAAC,OAAO,EAAE,UAAU,CAAC,CAAA;QAC9C,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACb,MAAM,iBAAS,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;QAC3B,CAAC;IACH,CAAC;CACF;AAhGD,gCAgGC","sourcesContent":["import { LexiconDoc, Lexicons, ValidationError } from '@atproto/lexicon'\nimport {\n  FetchHandler,\n  FetchHandlerObject,\n  FetchHandlerOptions,\n  buildFetchHandler,\n} from './fetch-handler'\nimport {\n  CallOptions,\n  Gettable,\n  QueryParams,\n  ResponseType,\n  XRPCError,\n  XRPCInvalidResponseError,\n  XRPCResponse,\n  httpResponseCodeToEnum,\n} from './types'\nimport {\n  combineHeaders,\n  constructMethodCallHeaders,\n  constructMethodCallUrl,\n  encodeMethodCallBody,\n  getMethodSchemaHTTPMethod,\n  httpResponseBodyParse,\n  isErrorResponseBody,\n} from './util'\n\nexport class XrpcClient {\n  readonly fetchHandler: FetchHandler\n  readonly headers = new Map<string, Gettable<null | string>>()\n  readonly lex: Lexicons\n\n  constructor(\n    fetchHandlerOpts: FetchHandler | FetchHandlerObject | FetchHandlerOptions,\n    // \"Lexicons\" is redundant here (because that class implements\n    // \"Iterable<LexiconDoc>\") but we keep it for explicitness:\n    lex: Lexicons | Iterable<LexiconDoc>,\n  ) {\n    this.fetchHandler = buildFetchHandler(fetchHandlerOpts)\n\n    this.lex = lex instanceof Lexicons ? lex : new Lexicons(lex)\n  }\n\n  setHeader(key: string, value: Gettable<null | string>): void {\n    this.headers.set(key.toLowerCase(), value)\n  }\n\n  unsetHeader(key: string): void {\n    this.headers.delete(key.toLowerCase())\n  }\n\n  clearHeaders(): void {\n    this.headers.clear()\n  }\n\n  async call(\n    methodNsid: string,\n    params?: QueryParams,\n    data?: unknown,\n    opts?: CallOptions,\n  ): Promise<XRPCResponse> {\n    const def = this.lex.getDefOrThrow(methodNsid)\n    if (!def || (def.type !== 'query' && def.type !== 'procedure')) {\n      throw new TypeError(\n        `Invalid lexicon: ${methodNsid}. Must be a query or procedure.`,\n      )\n    }\n\n    // @TODO: should we validate the params and data here?\n    // this.lex.assertValidXrpcParams(methodNsid, params)\n    // if (data !== undefined) {\n    //   this.lex.assertValidXrpcInput(methodNsid, data)\n    // }\n\n    const reqUrl = constructMethodCallUrl(methodNsid, def, params)\n    const reqMethod = getMethodSchemaHTTPMethod(def)\n    const reqHeaders = constructMethodCallHeaders(def, data, opts)\n    const reqBody = encodeMethodCallBody(reqHeaders, data)\n\n    // The duplex field is required for streaming bodies, but not yet reflected\n    // anywhere in docs or types. See whatwg/fetch#1438, nodejs/node#46221.\n    const init: RequestInit & { duplex: 'half' } = {\n      method: reqMethod,\n      headers: combineHeaders(reqHeaders, this.headers),\n      body: reqBody,\n      duplex: 'half',\n      redirect: 'follow',\n      signal: opts?.signal,\n    }\n\n    try {\n      const response = await this.fetchHandler.call(undefined, reqUrl, init)\n\n      const resStatus = response.status\n      const resHeaders = Object.fromEntries(response.headers.entries())\n      const resBodyBytes = await response.arrayBuffer()\n      const resBody = httpResponseBodyParse(\n        response.headers.get('content-type'),\n        resBodyBytes,\n      )\n\n      const resCode = httpResponseCodeToEnum(resStatus)\n      if (resCode !== ResponseType.Success) {\n        const { error = undefined, message = undefined } =\n          resBody && isErrorResponseBody(resBody) ? resBody : {}\n        throw new XRPCError(resCode, error, message, resHeaders)\n      }\n\n      try {\n        this.lex.assertValidXrpcOutput(methodNsid, resBody)\n      } catch (e: unknown) {\n        if (e instanceof ValidationError) {\n          throw new XRPCInvalidResponseError(methodNsid, e, resBody)\n        }\n\n        throw e\n      }\n\n      return new XRPCResponse(resBody, resHeaders)\n    } catch (err) {\n      throw XRPCError.from(err)\n    }\n  }\n}\n"]}