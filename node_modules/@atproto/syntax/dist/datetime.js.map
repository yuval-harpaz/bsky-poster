{"version":3,"file":"datetime.js","sourceRoot":"","sources":["../src/datetime.ts"],"names":[],"mappings":"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","sourcesContent":["/** An ISO 8601 formatted datetime string (YYYY-MM-DDTHH:mm:ss.sssZ) */\nexport type DatetimeString =\n  `${string}-${string}-${string}T${string}:${string}:${string}${'Z' | `+${string}` | `-${string}`}`\n\n// Allow date.toISOString() to be used where datetime format is expected\ndeclare global {\n  interface Date {\n    toISOString(): `${string}-${string}-${string}T${string}:${string}:${string}Z`\n  }\n}\n\n/* Validates datetime string against atproto Lexicon 'datetime' format.\n * Syntax is described at: https://atproto.com/specs/lexicon#datetime\n */\nexport function ensureValidDatetime(\n  dtStr: string,\n): asserts dtStr is DatetimeString {\n  const date = new Date(dtStr)\n  // must parse as ISO 8601; this also verifies semantics like month is not 13 or 00\n  if (isNaN(date.getTime())) {\n    throw new InvalidDatetimeError('datetime did not parse as ISO 8601')\n  }\n  if (date.toISOString().startsWith('-')) {\n    throw new InvalidDatetimeError('datetime normalized to a negative time')\n  }\n  // regex and other checks for RFC-3339\n  if (\n    !/^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-6][0-9]:[0-6][0-9](.[0-9]{1,20})?(Z|([+-][0-2][0-9]:[0-5][0-9]))$/.test(\n      dtStr,\n    )\n  ) {\n    throw new InvalidDatetimeError(\"datetime didn't validate via regex\")\n  }\n  if (dtStr.length > 64) {\n    throw new InvalidDatetimeError('datetime is too long (64 chars max)')\n  }\n  if (dtStr.endsWith('-00:00')) {\n    throw new InvalidDatetimeError(\n      'datetime can not use \"-00:00\" for UTC timezone',\n    )\n  }\n  if (dtStr.startsWith('000')) {\n    throw new InvalidDatetimeError('datetime so close to year zero not allowed')\n  }\n}\n\n/* Same logic as ensureValidDatetime(), but returns a boolean instead of throwing an exception.\n */\nexport function isValidDatetime(dtStr: string): dtStr is DatetimeString {\n  try {\n    ensureValidDatetime(dtStr)\n  } catch (err) {\n    if (err instanceof InvalidDatetimeError) {\n      return false\n    }\n    throw err\n  }\n\n  return true\n}\n\n/* Takes a flexible datetime string and normalizes representation.\n *\n * This function will work with any valid atproto datetime (eg, anything which isValidDatetime() is true for). It *additionally* is more flexible about accepting datetimes that don't comply to RFC 3339, or are missing timezone information, and normalizing them to a valid datetime.\n *\n * One use-case is a consistent, sortable string. Another is to work with older invalid createdAt datetimes.\n *\n * Successful output will be a valid atproto datetime with millisecond precision (3 sub-second digits) and UTC timezone with trailing 'Z' syntax. Throws `InvalidDatetimeError` if the input string could not be parsed as a datetime, even with permissive parsing.\n *\n * Expected output format: YYYY-MM-DDTHH:mm:ss.sssZ\n */\nexport function normalizeDatetime(dtStr: string): DatetimeString {\n  if (isValidDatetime(dtStr)) {\n    const outStr = new Date(dtStr).toISOString()\n    if (isValidDatetime(outStr)) {\n      return outStr\n    }\n  }\n\n  // check if this permissive datetime is missing a timezone\n  if (!/.*(([+-]\\d\\d:?\\d\\d)|[a-zA-Z])$/.test(dtStr)) {\n    const date = new Date(dtStr + 'Z')\n    if (!isNaN(date.getTime())) {\n      const tzStr = date.toISOString()\n      if (isValidDatetime(tzStr)) {\n        return tzStr\n      }\n    }\n  }\n\n  // finally try parsing as simple datetime\n  const date = new Date(dtStr)\n  if (isNaN(date.getTime())) {\n    throw new InvalidDatetimeError(\n      'datetime did not parse as any timestamp format',\n    )\n  }\n  const isoStr = date.toISOString()\n  if (isValidDatetime(isoStr)) {\n    return isoStr\n  } else {\n    throw new InvalidDatetimeError(\n      'datetime normalized to invalid timestamp string',\n    )\n  }\n}\n\n/* Variant of normalizeDatetime() which always returns a valid datetime strings.\n *\n * If a InvalidDatetimeError is encountered, returns the UNIX epoch time as a UTC datetime (1970-01-01T00:00:00.000Z).\n */\nexport const normalizeDatetimeAlways = (dtStr: string): DatetimeString => {\n  try {\n    return normalizeDatetime(dtStr)\n  } catch (err) {\n    if (err instanceof InvalidDatetimeError) {\n      return new Date(0).toISOString()\n    }\n    throw err\n  }\n}\n\n/* Indicates a datetime string did not pass full atproto Lexicon datetime string format checks.\n */\nexport class InvalidDatetimeError extends Error {}\n"]}