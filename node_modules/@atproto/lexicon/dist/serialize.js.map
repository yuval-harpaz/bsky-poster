{"version":3,"file":"serialize.js","sourceRoot":"","sources":["../src/serialize.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable import/no-deprecated */\n\nimport { CID } from 'multiformats/cid'\nimport {\n  IpldValue,\n  JsonValue,\n  check,\n  ipldToJson,\n  jsonToIpld,\n} from '@atproto/common-web'\nimport { BlobRef, jsonBlobRef } from './blob-refs'\n\n/**\n * @note this is equivalent to `unknown` because of {@link IpldValue} being `unknown`.\n * @deprecated Use {@link Lex} from `@atproto/lex-data` instead.\n */\nexport type LexValue = unknown\n\n/**\n * @deprecated Use {@link TypedLexMap} from `@atproto/lex-data` instead.\n */\nexport type RepoRecord = Record<string, LexValue>\n\n// @NOTE avoiding use of check.is() here only because it makes\n// these implementations slow, and they often live in hot paths.\n\n/**\n * @deprecated Use `LexValue` from `@atproto/lex-data` instead (which doesn't need conversion to IPLD).\n */\nexport const lexToIpld = (val: LexValue): IpldValue => {\n  // walk arrays\n  if (Array.isArray(val)) {\n    return val.map((item) => lexToIpld(item))\n  }\n  // objects\n  if (val && typeof val === 'object') {\n    // convert blobs, leaving the original encoding so that we don't change CIDs on re-encode\n    if (val instanceof BlobRef) {\n      return val.original\n    }\n    // retain cids & bytes\n    if (CID.asCID(val) || val instanceof Uint8Array) {\n      return val\n    }\n    // walk plain objects\n    const toReturn = {}\n    for (const key of Object.keys(val)) {\n      toReturn[key] = lexToIpld(val[key])\n    }\n    return toReturn\n  }\n  // pass through\n  return val\n}\n\n/**\n * @deprecated Use `LexValue` from `@atproto/lex-data` instead instead (which doesn't need conversion to IPLD).\n */\nexport const ipldToLex = (val: IpldValue): LexValue => {\n  // map arrays\n  if (Array.isArray(val)) {\n    return val.map((item) => ipldToLex(item))\n  }\n  // objects\n  if (val && typeof val === 'object') {\n    // convert blobs, using hints to avoid expensive is() check\n    if (\n      (val['$type'] === 'blob' ||\n        (typeof val['cid'] === 'string' &&\n          typeof val['mimeType'] === 'string')) &&\n      check.is(val, jsonBlobRef)\n    ) {\n      return BlobRef.fromJsonRef(val)\n    }\n    // retain cids, bytes\n    if (CID.asCID(val) || val instanceof Uint8Array) {\n      return val\n    }\n    // map plain objects\n    const toReturn = {}\n    for (const key of Object.keys(val)) {\n      toReturn[key] = ipldToLex(val[key])\n    }\n    return toReturn\n  }\n  // pass through\n  return val\n}\n\nexport const lexToJson = (val: LexValue): JsonValue => {\n  return ipldToJson(lexToIpld(val))\n}\n\nexport const stringifyLex = (val: LexValue): string => {\n  return JSON.stringify(lexToJson(val))\n}\n\nexport const jsonToLex = (val: JsonValue): LexValue => {\n  return ipldToLex(jsonToIpld(val))\n}\n\nexport const jsonStringToLex = (val: string): LexValue => {\n  return jsonToLex(JSON.parse(val))\n}\n"]}