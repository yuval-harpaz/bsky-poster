{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable import/no-deprecated */\n\nimport { z } from 'zod'\nimport { validateLanguage } from '@atproto/common-web'\nimport { isValidNsid } from '@atproto/syntax'\nimport { requiredPropertiesRefinement } from './util'\n\nexport const languageSchema = z\n  .string()\n  .refine(validateLanguage, 'Invalid BCP47 language tag')\n\nexport const lexLang = z.record(languageSchema, z.string().optional())\n\nexport type LexLang = z.infer<typeof lexLang>\n\n// primitives\n// =\n\nexport const lexBoolean = z.object({\n  type: z.literal('boolean'),\n  description: z.string().optional(),\n  default: z.boolean().optional(),\n  const: z.boolean().optional(),\n})\nexport type LexBoolean = z.infer<typeof lexBoolean>\n\nexport const lexInteger = z.object({\n  type: z.literal('integer'),\n  description: z.string().optional(),\n  default: z.number().int().optional(),\n  minimum: z.number().int().optional(),\n  maximum: z.number().int().optional(),\n  enum: z.number().int().array().optional(),\n  const: z.number().int().optional(),\n})\nexport type LexInteger = z.infer<typeof lexInteger>\n\nexport const lexStringFormat = z.enum([\n  'datetime',\n  'uri',\n  'at-uri',\n  'did',\n  'handle',\n  'at-identifier',\n  'nsid',\n  'cid',\n  'language',\n  'tid',\n  'record-key',\n])\nexport type LexStringFormat = z.infer<typeof lexStringFormat>\n\nexport const lexString = z.object({\n  type: z.literal('string'),\n  format: lexStringFormat.optional(),\n  description: z.string().optional(),\n  default: z.string().optional(),\n  minLength: z.number().int().optional(),\n  maxLength: z.number().int().optional(),\n  minGraphemes: z.number().int().optional(),\n  maxGraphemes: z.number().int().optional(),\n  enum: z.string().array().optional(),\n  const: z.string().optional(),\n  knownValues: z.string().array().optional(),\n})\nexport type LexString = z.infer<typeof lexString>\n\nexport const lexUnknown = z.object({\n  type: z.literal('unknown'),\n  description: z.string().optional(),\n})\nexport type LexUnknown = z.infer<typeof lexUnknown>\n\nexport const lexPrimitive = z.discriminatedUnion('type', [\n  lexBoolean,\n  lexInteger,\n  lexString,\n  lexUnknown,\n])\nexport type LexPrimitive = z.infer<typeof lexPrimitive>\n\n// ipld types\n// =\n\nexport const lexBytes = z.object({\n  type: z.literal('bytes'),\n  description: z.string().optional(),\n  maxLength: z.number().optional(),\n  minLength: z.number().optional(),\n})\nexport type LexBytes = z.infer<typeof lexBytes>\n\nexport const lexCidLink = z.object({\n  type: z.literal('cid-link'),\n  description: z.string().optional(),\n})\nexport type LexCidLink = z.infer<typeof lexCidLink>\n\nexport const lexIpldType = z.discriminatedUnion('type', [lexBytes, lexCidLink])\nexport type LexIpldType = z.infer<typeof lexIpldType>\n\n// references\n// =\n\nexport const lexRef = z.object({\n  type: z.literal('ref'),\n  description: z.string().optional(),\n  ref: z.string(),\n})\nexport type LexRef = z.infer<typeof lexRef>\n\nexport const lexRefUnion = z.object({\n  type: z.literal('union'),\n  description: z.string().optional(),\n  refs: z.string().array(),\n  closed: z.boolean().optional(),\n})\nexport type LexRefUnion = z.infer<typeof lexRefUnion>\n\nexport const lexRefVariant = z.discriminatedUnion('type', [lexRef, lexRefUnion])\nexport type LexRefVariant = z.infer<typeof lexRefVariant>\n\n// blobs\n// =\n\nexport const lexBlob = z.object({\n  type: z.literal('blob'),\n  description: z.string().optional(),\n  accept: z.string().array().optional(),\n  maxSize: z.number().optional(),\n})\nexport type LexBlob = z.infer<typeof lexBlob>\n\n// complex types\n// =\n\nexport const lexArray = z.object({\n  type: z.literal('array'),\n  description: z.string().optional(),\n  items: z.discriminatedUnion('type', [\n    // lexPrimitive\n    lexBoolean,\n    lexInteger,\n    lexString,\n    lexUnknown,\n    // lexIpldType\n    lexBytes,\n    lexCidLink,\n    // lexRefVariant\n    lexRef,\n    lexRefUnion,\n    // other\n    lexBlob,\n  ]),\n  minLength: z.number().int().optional(),\n  maxLength: z.number().int().optional(),\n})\nexport type LexArray = z.infer<typeof lexArray>\n\nexport const lexPrimitiveArray = lexArray.merge(\n  z.object({\n    items: lexPrimitive,\n  }),\n)\nexport type LexPrimitiveArray = z.infer<typeof lexPrimitiveArray>\n\nexport const lexToken = z.object({\n  type: z.literal('token'),\n  description: z.string().optional(),\n})\nexport type LexToken = z.infer<typeof lexToken>\n\nexport const lexObject = z\n  .object({\n    type: z.literal('object'),\n    description: z.string().optional(),\n    required: z.string().array().optional(),\n    nullable: z.string().array().optional(),\n    properties: z.record(\n      z.string(),\n      z.discriminatedUnion('type', [\n        lexArray,\n\n        // lexPrimitive\n        lexBoolean,\n        lexInteger,\n        lexString,\n        lexUnknown,\n        // lexIpldType\n        lexBytes,\n        lexCidLink,\n        // lexRefVariant\n        lexRef,\n        lexRefUnion,\n        // other\n        lexBlob,\n      ]),\n    ),\n  })\n  .superRefine(requiredPropertiesRefinement)\nexport type LexObject = z.infer<typeof lexObject>\n\n// permissions\n// =\n\nconst lexPermission = z.intersection(\n  z.object({\n    type: z.literal('permission'),\n    resource: z.string().nonempty(),\n  }),\n  z.record(\n    z.string(),\n    z\n      .union([\n        z.array(z.union([z.string(), z.number().int(), z.boolean()])),\n\n        z.boolean(),\n        z.number().int(),\n        z.string(),\n      ])\n      .optional(),\n  ),\n)\n\nexport type LexPermission = z.infer<typeof lexPermission>\n\nexport const lexPermissionSet = z.object({\n  type: z.literal('permission-set'),\n  description: z.string().optional(),\n  title: z.string().optional(),\n  'title:lang': lexLang.optional(),\n  detail: z.string().optional(),\n  'detail:lang': lexLang.optional(),\n  permissions: z.array(lexPermission),\n})\n\nexport type LexPermissionSet = z.infer<typeof lexPermissionSet>\n\n// xrpc\n// =\n\nexport const lexXrpcParameters = z\n  .object({\n    type: z.literal('params'),\n    description: z.string().optional(),\n    required: z.string().array().optional(),\n    properties: z.record(\n      z.string(),\n      z.discriminatedUnion('type', [\n        lexPrimitiveArray,\n\n        // lexPrimitive\n        lexBoolean,\n        lexInteger,\n        lexString,\n        lexUnknown,\n      ]),\n    ),\n  })\n  .superRefine(requiredPropertiesRefinement)\nexport type LexXrpcParameters = z.infer<typeof lexXrpcParameters>\n\nexport const lexXrpcBody = z.object({\n  description: z.string().optional(),\n  encoding: z.string(),\n  // @NOTE using discriminatedUnion with a refined schema requires zod >= 4\n  schema: z.union([lexRefVariant, lexObject]).optional(),\n})\nexport type LexXrpcBody = z.infer<typeof lexXrpcBody>\n\nexport const lexXrpcError = z.object({\n  name: z.string(),\n  description: z.string().optional(),\n})\nexport type LexXrpcError = z.infer<typeof lexXrpcError>\n\nexport const lexXrpcQuery = z.object({\n  type: z.literal('query'),\n  description: z.string().optional(),\n  parameters: lexXrpcParameters.optional(),\n  output: lexXrpcBody.optional(),\n  errors: lexXrpcError.array().optional(),\n})\nexport type LexXrpcQuery = z.infer<typeof lexXrpcQuery>\n\nexport const lexXrpcProcedure = z.object({\n  type: z.literal('procedure'),\n  description: z.string().optional(),\n  parameters: lexXrpcParameters.optional(),\n  input: lexXrpcBody.optional(),\n  output: lexXrpcBody.optional(),\n  errors: lexXrpcError.array().optional(),\n})\nexport type LexXrpcProcedure = z.infer<typeof lexXrpcProcedure>\n\nexport const lexXrpcSubscription = z.object({\n  type: z.literal('subscription'),\n  description: z.string().optional(),\n  parameters: lexXrpcParameters.optional(),\n  message: z.object({\n    description: z.string().optional(),\n    schema: lexRefUnion,\n  }),\n  errors: lexXrpcError.array().optional(),\n})\nexport type LexXrpcSubscription = z.infer<typeof lexXrpcSubscription>\n\n// database\n// =\n\nexport const lexRecord = z.object({\n  type: z.literal('record'),\n  description: z.string().optional(),\n  key: z.string().optional(),\n  record: lexObject,\n})\nexport type LexRecord = z.infer<typeof lexRecord>\n\n// core\n// =\n\n// We need to use `z.custom` here because\n// lexXrpcProperty and lexObject are refined\n// `z.union` would work, but it's too slow\n// see #915 for details\nexport const lexUserType = z.custom<\n  | LexRecord\n  | LexPermissionSet\n  | LexXrpcQuery\n  | LexXrpcProcedure\n  | LexXrpcSubscription\n  | LexBlob\n  | LexArray\n  | LexToken\n  | LexObject\n  | LexBoolean\n  | LexInteger\n  | LexString\n  | LexBytes\n  | LexCidLink\n  | LexUnknown\n>(\n  (val) => {\n    if (!val || typeof val !== 'object') {\n      return\n    }\n\n    if (val['type'] === undefined) {\n      return\n    }\n\n    switch (val['type']) {\n      case 'record':\n        return lexRecord.parse(val)\n\n      case 'permission-set':\n        return lexPermissionSet.parse(val)\n\n      case 'query':\n        return lexXrpcQuery.parse(val)\n      case 'procedure':\n        return lexXrpcProcedure.parse(val)\n      case 'subscription':\n        return lexXrpcSubscription.parse(val)\n\n      case 'blob':\n        return lexBlob.parse(val)\n\n      case 'array':\n        return lexArray.parse(val)\n      case 'token':\n        return lexToken.parse(val)\n      case 'object':\n        return lexObject.parse(val)\n\n      case 'boolean':\n        return lexBoolean.parse(val)\n      case 'integer':\n        return lexInteger.parse(val)\n      case 'string':\n        return lexString.parse(val)\n      case 'bytes':\n        return lexBytes.parse(val)\n      case 'cid-link':\n        return lexCidLink.parse(val)\n      case 'unknown':\n        return lexUnknown.parse(val)\n    }\n  },\n  (val) => {\n    if (!val || typeof val !== 'object') {\n      return {\n        message: 'Must be an object',\n        fatal: true,\n      }\n    }\n\n    if (val['type'] === undefined) {\n      return {\n        message: 'Must have a type',\n        fatal: true,\n      }\n    }\n\n    if (typeof val['type'] !== 'string') {\n      return {\n        message: 'Type property must be a string',\n        fatal: true,\n      }\n    }\n\n    return {\n      message: `Invalid type: ${val['type']} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,\n      fatal: true,\n    }\n  },\n)\nexport type LexUserType = z.infer<typeof lexUserType>\n\nexport const lexiconDoc = z\n  .object({\n    lexicon: z.literal(1),\n    id: z.string().refine(isValidNsid, {\n      message: 'Must be a valid NSID',\n    }),\n    revision: z.number().optional(),\n    description: z.string().optional(),\n    defs: z.record(z.string(), lexUserType),\n  })\n  .refine(\n    (doc) => {\n      for (const [defId, def] of Object.entries(doc.defs)) {\n        if (\n          defId !== 'main' &&\n          (def.type === 'record' ||\n            def.type === 'permission-set' ||\n            def.type === 'procedure' ||\n            def.type === 'query' ||\n            def.type === 'subscription')\n        ) {\n          return false\n        }\n      }\n      return true\n    },\n    {\n      message: `Records, permission sets, procedures, queries, and subscriptions must be the main definition.`,\n    },\n  )\nexport type LexiconDoc = z.infer<typeof lexiconDoc>\n\n// helpers\n// =\n\nexport function isValidLexiconDoc(v: unknown): v is LexiconDoc {\n  return lexiconDoc.safeParse(v).success\n}\n\nexport function isObj<V>(v: V): v is V & object {\n  return v != null && typeof v === 'object'\n}\n\nexport type DiscriminatedObject = { $type: string }\nexport function isDiscriminatedObject(v: unknown): v is DiscriminatedObject {\n  return isObj(v) && '$type' in v && typeof v.$type === 'string'\n}\n\nexport function parseLexiconDoc(v: unknown): LexiconDoc {\n  lexiconDoc.parse(v)\n  return v as LexiconDoc\n}\n\nexport type ValidationResult<V = unknown> =\n  | {\n      success: true\n      value: V\n    }\n  | {\n      success: false\n      error: ValidationError\n    }\n\nexport class ValidationError extends Error {}\nexport class InvalidLexiconError extends Error {}\nexport class LexiconDefNotFoundError extends Error {}\n"]}