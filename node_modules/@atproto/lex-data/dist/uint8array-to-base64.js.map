{"version":3,"file":"uint8array-to-base64.js","sourceRoot":"","sources":["../src/uint8array-to-base64.ts"],"names":[],"mappings":";;;AAiDA,4CAKC;AAtDD,qDAAgD;AAChD,6DAAqD;AAGrD,MAAM,MAAM,GAAG,+BAAY,CAAA;AAed,QAAA,cAAc,GACzB,OAAO,UAAU,CAAC,SAAS,CAAC,QAAQ,KAAK,UAAU;IACjD,CAAC,CAAC,SAAS,cAAc,CACrB,KAAiB,EACjB,WAA2B,QAAQ;QAEnC,OAAO,KAAK,CAAC,QAAS,CAAC,EAAE,QAAQ,EAAE,WAAW,EAAE,IAAI,EAAE,CAAC,CAAA;IACzD,CAAC;IACH,CAAC,CAAC,iCAAiC,CAAC,IAAI,CAAA;AAE/B,QAAA,YAAY,GAAG,MAAM;IAChC,CAAC,CAAC,SAAS,YAAY,CACnB,KAAiB,EACjB,WAA2B,QAAQ;QAEnC,MAAM,MAAM,GAAG,KAAK,YAAY,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;QACnE,MAAM,GAAG,GAAG,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAA;QAErC,uDAAuD;QACvD,0EAA0E;QAC1E,sEAAsE;QACtE,6DAA6D;QAC7D,OAAO,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,SAAS,CAAC,IAAI;YACtD,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,SAAS,CAAC,IAAI;gBACjD,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,OAAO;gBAC1B,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM;YAC3B,CAAC,CAAC,GAAG,CAAA;IACT,CAAC;IACH,CAAC,CAAC,iCAAiC,CAAC,IAAI,CAAA;AAE1C,SAAgB,gBAAgB,CAC9B,KAAiB,EACjB,WAA2B,QAAQ;IAEnC,OAAO,IAAA,oBAAQ,EAAC,KAAK,EAAE,QAAQ,CAAC,CAAA;AAClC,CAAC","sourcesContent":["import { toString } from 'uint8arrays/to-string'\nimport { NodeJSBuffer } from './lib/nodejs-buffer.js'\nimport { Base64Alphabet } from './uint8array-base64.js'\n\nconst Buffer = NodeJSBuffer\n\ndeclare global {\n  interface Uint8Array {\n    /**\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/toBase64 Uint8Array.prototype.toBase64()}\n     */\n    toBase64?: (options?: {\n      /** @default 'base64' */\n      alphabet?: 'base64' | 'base64url'\n      omitPadding?: boolean\n    }) => string\n  }\n}\n\nexport const toBase64Native =\n  typeof Uint8Array.prototype.toBase64 === 'function'\n    ? function toBase64Native(\n        bytes: Uint8Array,\n        alphabet: Base64Alphabet = 'base64',\n      ): string {\n        return bytes.toBase64!({ alphabet, omitPadding: true })\n      }\n    : /* v8 ignore next -- @preserve */ null\n\nexport const toBase64Node = Buffer\n  ? function toBase64Node(\n      bytes: Uint8Array,\n      alphabet: Base64Alphabet = 'base64',\n    ): string {\n      const buffer = bytes instanceof Buffer ? bytes : Buffer.from(bytes)\n      const b64 = buffer.toString(alphabet)\n\n      // @NOTE We strip padding for strict compatibility with\n      // uint8arrays.toString behavior. Tests failing because of the presence of\n      // padding are not really synonymous with an actual error and we might\n      // (should?) actually want to keep the padding at some point.\n      return b64.charCodeAt(b64.length - 1) === /* '=' */ 0x3d\n        ? b64.charCodeAt(b64.length - 2) === /* '=' */ 0x3d\n          ? b64.slice(0, -2) // '=='\n          : b64.slice(0, -1) // '='\n        : b64\n    }\n  : /* v8 ignore next -- @preserve */ null\n\nexport function toBase64Ponyfill(\n  bytes: Uint8Array,\n  alphabet: Base64Alphabet = 'base64',\n): string {\n  return toString(bytes, alphabet)\n}\n"]}