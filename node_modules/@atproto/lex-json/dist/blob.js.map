{"version":3,"file":"blob.js","sourceRoot":"","sources":["../src/blob.ts"],"names":[],"mappings":";;AAQA,oCA2BC;AAnCD,gDAK0B;AAC1B,uCAAwC;AAExC,SAAgB,YAAY,CAC1B,KAAa,EACb,OAAkC;IAElC,IAAI,KAAK,CAAC,KAAK,KAAK,MAAM;QAAE,OAAO,SAAS,CAAA;IAE5C,MAAM,GAAG,GAAG,KAAK,EAAE,GAAG,CAAA;IACtB,IAAI,CAAC,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ;QAAE,OAAO,SAAS,CAAA;IAErD,8EAA8E;IAC9E,oEAAoE;IACpE,qEAAqE;IACrE,iDAAiD;IAEjD,IAAI,OAAO,IAAI,GAAG,EAAE,CAAC;QACnB,MAAM,GAAG,GAAG,IAAA,sBAAY,EAAC,GAAG,CAAC,CAAA;QAC7B,IAAI,CAAC,GAAG;YAAE,OAAO,SAAS,CAAA;QAE1B,MAAM,IAAI,GAAG,EAAE,GAAG,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,CAAA;QACnC,IAAI,IAAA,oBAAS,EAAC,IAAI,EAAE,OAAO,CAAC;YAAE,OAAO,IAAI,CAAA;IAC3C,CAAC;IAED,IAAI,IAAA,oBAAS,EAAC,KAAK,CAAC,EAAE,CAAC;QACrB,OAAO,KAAK,CAAA;IACd,CAAC;IAED,OAAO,SAAS,CAAA;AAClB,CAAC","sourcesContent":["import {\n  BlobRef,\n  BlobRefValidationOptions,\n  LexMap,\n  isBlobRef,\n} from '@atproto/lex-data'\nimport { parseLexLink } from './link.js'\n\nexport function parseBlobRef(\n  input: LexMap,\n  options?: BlobRefValidationOptions,\n): BlobRef | undefined {\n  if (input.$type !== 'blob') return undefined\n\n  const ref = input?.ref\n  if (!ref || typeof ref !== 'object') return undefined\n\n  // @NOTE Because json to lex conversion can be performed both in a depth-first\n  // manner (e.g. via lexParse) or in a breadth-first manner (e.g. via\n  // jsonToLex), the `ref` property may either be a LexMap with a $link\n  // property, or it may already be a CID instance.\n\n  if ('$link' in ref) {\n    const cid = parseLexLink(ref)\n    if (!cid) return undefined\n\n    const blob = { ...input, ref: cid }\n    if (isBlobRef(blob, options)) return blob\n  }\n\n  if (isBlobRef(input)) {\n    return input\n  }\n\n  return undefined\n}\n"]}