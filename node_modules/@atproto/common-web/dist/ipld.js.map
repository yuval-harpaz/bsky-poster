{"version":3,"file":"ipld.js","sourceRoot":"","sources":["../src/ipld.ts"],"names":[],"mappings":";;;AAAA,gDAAuD;AACvD,gDAAmE;AAcnE;;;GAGG;AACI,MAAM,UAAU,GAAG,CAAC,GAAoB,EAAa,EAAE;IAC5D,OAAO,IAAA,oBAAS,EAAC,GAAgB,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAA;AACvD,CAAC,CAAA;AAFY,QAAA,UAAU,cAEtB;AAED;;;GAGG;AACI,MAAM,UAAU,GAAG,CAAC,GAAc,EAAmB,EAAE;IAC5D,qBAAqB;IACrB,IAAI,GAAG,KAAK,SAAS;QAAE,OAAO,GAAG,CAAA;IACjC,IAAI,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC;QAAE,OAAO,GAAG,CAAA;IAEjC,OAAO,IAAA,oBAAS,EAAC,GAAe,CAAC,CAAA;AACnC,CAAC,CAAA;AANY,QAAA,UAAU,cAMtB;AAED;;;GAGG;AACI,MAAM,UAAU,GAAG,CAAC,CAAY,EAAE,CAAY,EAAW,EAAE;IAChE,IAAI,CAAC,IAAA,oBAAS,EAAC,CAAa,EAAE,CAAa,CAAC;QAAE,OAAO,KAAK,CAAA;IAE1D,8EAA8E;IAC9E,OAAO;IACP,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;QAAE,OAAO,KAAK,CAAA;IAEjC,OAAO,IAAI,CAAA;AACb,CAAC,CAAA;AARY,QAAA,UAAU,cAQtB","sourcesContent":["import { LexValue, lexEquals } from '@atproto/lex-data'\nimport { JsonValue, jsonToLex, lexToJson } from '@atproto/lex-json'\n\n/**\n * @deprecated Use {@link JsonValue} from `@atproto/lex-cbor` instead.\n */\nexport type LegacyJsonValue = unknown\n\nexport type { LegacyJsonValue as JsonValue }\n\n/**\n * @deprecated Use {@link LexValue} from `@atproto/lex-cbor` instead.\n */\nexport type IpldValue = unknown\n\n/**\n * Converts a JSON-compatible value to an IPLD-compatible value.\n * @deprecated Use {@link jsonToLex} from `@atproto/lex-cbor` instead.\n */\nexport const jsonToIpld = (val: LegacyJsonValue): IpldValue => {\n  return jsonToLex(val as JsonValue, { strict: false })\n}\n\n/**\n * Converts an IPLD-compatible value to a JSON-compatible value.\n * @deprecated Use {@link lexToJson} from `@atproto/lex-cbor` instead.\n */\nexport const ipldToJson = (val: IpldValue): LegacyJsonValue => {\n  // Legacy behavior(s)\n  if (val === undefined) return val\n  if (Number.isNaN(val)) return val\n\n  return lexToJson(val as LexValue)\n}\n\n/**\n * Compares two IPLD-compatible values for deep equality.\n * @deprecated Use {@link lexEquals} from `@atproto/lex-cbor` instead.\n */\nexport const ipldEquals = (a: IpldValue, b: IpldValue): boolean => {\n  if (!lexEquals(a as LexValue, b as LexValue)) return false\n\n  // @NOTE The previous implementation used \"===\" which treats NaN as unequal to\n  // NaN.\n  if (Number.isNaN(a)) return false\n\n  return true\n}\n"]}