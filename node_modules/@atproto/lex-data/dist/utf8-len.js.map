{"version":3,"file":"utf8-len.js","sourceRoot":"","sources":["../src/utf8-len.ts"],"names":[],"mappings":";;;AAYA,wCAsCC;AAlDD,6DAAqD;AAErD,8EAA8E;AAC9E,+EAA+E;AAC/E,8EAA8E;AAEjE,QAAA,WAAW,GAAG,+BAAY;IACrC,CAAC,CAAC,SAAS,WAAW,CAAC,MAAc;QACjC,OAAO,+BAAa,CAAC,UAAU,CAAC,MAAM,EAAE,MAAM,CAAC,CAAA;IACjD,CAAC;IACH,CAAC,CAAC,iCAAiC,CAAC,IAAI,CAAA;AAE1C,SAAgB,cAAc,CAAC,MAAc;IAC3C,qEAAqE;IACrE,wEAAwE;IACxE,+DAA+D;IAE/D,qDAAqD;IAErD,mDAAmD;IACnD,IAAI,GAAG,GAAG,MAAM,CAAC,MAAM,CAAA;IACvB,IAAI,IAAY,CAAA;IAEhB,gEAAgE;IAChE,uBAAuB;IACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC;QAC1C,IAAI,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA;QAE3B,IAAI,IAAI,IAAI,IAAI,EAAE,CAAC;YACjB,gBAAgB;QAClB,CAAC;aAAM,IAAI,IAAI,IAAI,KAAK,EAAE,CAAC;YACzB,eAAe;YACf,GAAG,IAAI,CAAC,CAAA;QACV,CAAC;aAAM,CAAC;YACN,eAAe;YACf,GAAG,IAAI,CAAC,CAAA;YACR,sEAAsE;YACtE,+DAA+D;YAC/D,wEAAwE;YACxE,OAAO;YACP,IAAI,IAAI,IAAI,MAAM,IAAI,IAAI,IAAI,MAAM,EAAE,CAAC;gBACrC,IAAI,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC,CAAA;gBAC/B,IAAI,IAAI,IAAI,MAAM,IAAI,IAAI,IAAI,MAAM,EAAE,CAAC;oBACrC,CAAC,EAAE,CAAA;gBACL,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,OAAO,GAAG,CAAA;AACZ,CAAC","sourcesContent":["import { NodeJSBuffer } from './lib/nodejs-buffer.js'\n\n// @NOTE This file is not meant to be exported directly. Instead, we re-export\n// public functions from ./utf8.ts. The reason for this separation is that this\n// file allows to test both the NodeJS-optimized and ponyfill implementations.\n\nexport const utf8LenNode = NodeJSBuffer\n  ? function utf8LenNode(string: string): number {\n      return NodeJSBuffer!.byteLength(string, 'utf8')\n    }\n  : /* v8 ignore next -- @preserve */ null\n\nexport function utf8LenCompute(string: string): number {\n  // The code below is similar to TextEncoder's implementation of UTF-8\n  // encoding. However, using TextEncoder to get the byte length is slower\n  // as it requires allocating a new Uint8Array and copying data:\n\n  // return new TextEncoder().encode(string).byteLength\n\n  // The base length is the string length (all ASCII)\n  let len = string.length\n  let code: number\n\n  // The loop calculates the number of additional bytes needed for\n  // non-ASCII characters\n  for (let i = 0; i < string.length; i += 1) {\n    code = string.charCodeAt(i)\n\n    if (code <= 0x7f) {\n      // ASCII, 1 byte\n    } else if (code <= 0x7ff) {\n      // 2 bytes char\n      len += 1\n    } else {\n      // 3 bytes char\n      len += 2\n      // If the current char is a high surrogate, and the next char is a low\n      // surrogate, skip the next char as the total is a 4 bytes char\n      // (represented as a surrogate pair in UTF-16) and was already accounted\n      // for.\n      if (code >= 0xd800 && code <= 0xdbff) {\n        code = string.charCodeAt(i + 1)\n        if (code >= 0xdc00 && code <= 0xdfff) {\n          i++\n        }\n      }\n    }\n  }\n\n  return len\n}\n"]}