{"version":3,"file":"uint8array-from-base64.js","sourceRoot":"","sources":["../src/uint8array-from-base64.ts"],"names":[],"mappings":"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","sourcesContent":["import { fromString } from 'uint8arrays/from-string'\nimport { NodeJSBuffer } from './lib/nodejs-buffer.js'\nimport { Base64Alphabet } from './uint8array-base64.js'\n\nconst Buffer = NodeJSBuffer\n\ndeclare global {\n  interface Uint8ArrayConstructor {\n    /**\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/fromBase64 Uint8Array.fromBase64()}\n     */\n    fromBase64?: (\n      b64: string,\n      options?: {\n        /** @default 'base64' */\n        alphabet?: 'base64' | 'base64url'\n        lastChunkHandling?: 'loose' | 'strict' | 'stop-before-partial'\n      },\n    ) => Uint8Array\n  }\n}\n\nexport const fromBase64Native =\n  typeof Uint8Array.fromBase64 === 'function'\n    ? function fromBase64Native(\n        b64: string,\n        alphabet: Base64Alphabet = 'base64',\n      ): Uint8Array {\n        return Uint8Array.fromBase64!(b64, {\n          alphabet,\n          lastChunkHandling: 'loose',\n        })\n      }\n    : /* v8 ignore next -- @preserve */ null\n\nexport const fromBase64Node = Buffer\n  ? function fromBase64Node(\n      b64: string,\n      alphabet: Base64Alphabet = 'base64',\n    ): Uint8Array {\n      const bytes = Buffer.from(b64, alphabet)\n      verifyBase64ForBytes(b64, bytes)\n      // Convert to Uint8Array because even though Buffer is a sub class of\n      // Uint8Array, it serializes differently to Uint8Array (e.g. in JSON) and\n      // results in unexpected behavior downstream (e.g. in tests)\n      return new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n    }\n  : /* v8 ignore next -- @preserve */ null\n\nexport function fromBase64Ponyfill(\n  b64: string,\n  alphabet: Base64Alphabet = 'base64',\n): Uint8Array {\n  const bytes = fromString(b64, b64.endsWith('=') ? `${alphabet}pad` : alphabet)\n  verifyBase64ForBytes(b64, bytes)\n  return bytes\n}\n\n// @NOTE NodeJS will silently stop decoding at the first invalid character,\n// while \"uint8arrays/from-string\" will not validate that the padding is\n// correct. The following function performs basic validation to ensure that the\n// input was a valid base64 string. The availability of the \"bytes\" allows\n// to perform checks with O[1] complexity.\nfunction verifyBase64ForBytes(b64: string, bytes: Uint8Array): void {\n  const paddingCount = b64.endsWith('==') ? 2 : b64.endsWith('=') ? 1 : 0\n  const trimmedLength = b64.length - paddingCount\n  const expectedByteLength = Math.floor((trimmedLength * 3) / 4)\n  if (bytes.length !== expectedByteLength) {\n    throw new Error('Invalid base64 string')\n  }\n\n  const expectedB64Length = (bytes.length / 3) * 4\n  const expectedPaddingCount =\n    expectedB64Length % 4 === 0 ? 0 : 4 - (expectedB64Length % 4)\n  const expectedFullB64Length = expectedB64Length + expectedPaddingCount\n  if (b64.length > expectedFullB64Length) {\n    throw new Error('Invalid base64 string')\n  }\n\n  // The previous might still allow false positive if only the last few\n  // chars are invalid.\n  for (\n    let i = Math.ceil(expectedB64Length);\n    i < b64.length - paddingCount;\n    i++\n  ) {\n    const code = b64.charCodeAt(i)\n    if (\n      !(code >= 65 && code <= 90) && // A-Z\n      !(code >= 97 && code <= 122) && // a-z\n      !(code >= 48 && code <= 57) && // 0-9\n      code !== 43 && // +\n      code !== 47 // /\n    ) {\n      throw new Error('Invalid base64 string')\n    }\n  }\n}\n"]}