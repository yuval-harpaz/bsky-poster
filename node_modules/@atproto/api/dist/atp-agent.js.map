{"version":3,"file":"atp-agent.js","sourceRoot":"","sources":["../src/atp-agent.ts"],"names":[],"mappings":"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","sourcesContent":["import { getPdsEndpoint, isValidDidDoc } from '@atproto/common-web'\nimport {\n  ErrorResponseBody,\n  Gettable,\n  ResponseType,\n  XRPCError,\n  XrpcClient,\n  errorResponseBody,\n} from '@atproto/xrpc'\nimport { Agent } from './agent'\nimport {\n  ComAtprotoServerCreateAccount,\n  ComAtprotoServerCreateSession,\n  ComAtprotoServerGetSession,\n  ComAtprotoServerNS,\n  ComAtprotoServerRefreshSession,\n} from './client'\nimport { schemas } from './client/lexicons'\nimport { SessionManager } from './session-manager'\nimport {\n  AtpAgentLoginOpts,\n  AtpPersistSessionHandler,\n  AtpSessionData,\n} from './types'\n\nconst ReadableStream = globalThis.ReadableStream as\n  | typeof globalThis.ReadableStream\n  | undefined\n\nexport type AtpAgentOptions = {\n  service: string | URL\n  persistSession?: AtpPersistSessionHandler\n  fetch?: typeof globalThis.fetch\n  headers?: Iterable<[string, Gettable<null | string>]>\n}\n\n/**\n * A wrapper around the {@link Agent} class that uses credential based session\n * management. This class also exposes most of the session management methods\n * directly.\n *\n * This class will be deprecated in the near future. Use {@link Agent} directly\n * with a {@link CredentialSession} instead:\n *\n *  ```ts\n *  const session = new CredentialSession({\n *    service: new URL('https://example.com'),\n *  })\n *\n *  const agent = new Agent(session)\n *  ```\n */\nexport class AtpAgent extends Agent {\n  readonly sessionManager: CredentialSession\n\n  constructor(options: AtpAgentOptions | CredentialSession) {\n    const sessionManager =\n      options instanceof CredentialSession\n        ? options\n        : new CredentialSession(\n            new URL(options.service),\n            options.fetch,\n            options.persistSession,\n          )\n\n    super(sessionManager)\n\n    // This assignment is already being done in the super constructor, but we\n    // need to do it here to make TypeScript happy.\n    this.sessionManager = sessionManager\n\n    if (!(options instanceof CredentialSession) && options.headers) {\n      for (const [key, value] of options.headers) {\n        this.setHeader(key, value)\n      }\n    }\n  }\n\n  clone(): AtpAgent {\n    return this.copyInto(new AtpAgent(this.sessionManager))\n  }\n\n  get session() {\n    return this.sessionManager.session\n  }\n\n  get hasSession() {\n    return this.sessionManager.hasSession\n  }\n\n  get did() {\n    return this.sessionManager.did\n  }\n\n  get serviceUrl() {\n    return this.sessionManager.serviceUrl\n  }\n\n  get pdsUrl() {\n    return this.sessionManager.pdsUrl\n  }\n\n  get dispatchUrl() {\n    return this.sessionManager.dispatchUrl\n  }\n\n  /** @deprecated use {@link serviceUrl} instead */\n  get service() {\n    return this.serviceUrl\n  }\n\n  get persistSession() {\n    throw new Error(\n      'Cannot set persistSession directly. \"persistSession\" is defined through the constructor and will be invoked automatically when session data changes.',\n    )\n  }\n\n  set persistSession(v: unknown) {\n    throw new Error(\n      'Cannot set persistSession directly. \"persistSession\" must be defined in the constructor and can no longer be changed.',\n    )\n  }\n\n  /** @deprecated use {@link AtpAgent.serviceUrl} instead */\n  getServiceUrl() {\n    return this.serviceUrl\n  }\n\n  async resumeSession(\n    session: AtpSessionData,\n  ): Promise<ComAtprotoServerGetSession.Response> {\n    return this.sessionManager.resumeSession(session)\n  }\n\n  async createAccount(\n    data: ComAtprotoServerCreateAccount.InputSchema,\n    opts?: ComAtprotoServerCreateAccount.CallOptions,\n  ): Promise<ComAtprotoServerCreateAccount.Response> {\n    return this.sessionManager.createAccount(data, opts)\n  }\n\n  async login(\n    opts: AtpAgentLoginOpts,\n  ): Promise<ComAtprotoServerCreateSession.Response> {\n    return this.sessionManager.login(opts)\n  }\n\n  async logout(): Promise<void> {\n    return this.sessionManager.logout()\n  }\n}\n\n/**\n * Credentials (username / password) based session manager. Instances of this\n * class will typically be used as the session manager for an {@link AtpAgent}.\n * They can also be used with an {@link XrpcClient}, if you want to use you\n * own Lexicons.\n */\nexport class CredentialSession implements SessionManager {\n  public pdsUrl?: URL // The PDS URL, driven by the did doc\n  public session?: AtpSessionData\n  public refreshSessionPromise: Promise<void> | undefined\n\n  /**\n   * Private {@link ComAtprotoServerNS} used to perform session management API\n   * calls on the service endpoint. Calls performed by this agent will not be\n   * authenticated using the user's session to allow proper manual configuration\n   * of the headers when performing session management operations.\n   */\n  protected server = new ComAtprotoServerNS(\n    // Note that the use of the codegen \"schemas\" (to instantiate `this.api`),\n    // as well as the use of `ComAtprotoServerNS` will cause this class to\n    // reference (way) more code than it actually needs. It is not possible,\n    // with the current state of the codegen, to generate a client that only\n    // includes the methods that are actually used by this class. This is a\n    // known limitation that should be addressed in a future version of the\n    // codegen.\n    new XrpcClient((url, init) => {\n      return (0, this.fetch)(new URL(url, this.serviceUrl), init)\n    }, schemas),\n  )\n\n  constructor(\n    public readonly serviceUrl: URL,\n    public fetch = globalThis.fetch,\n    protected readonly persistSession?: AtpPersistSessionHandler,\n  ) {}\n\n  get did() {\n    return this.session?.did\n  }\n\n  get dispatchUrl() {\n    return this.pdsUrl || this.serviceUrl\n  }\n\n  get hasSession() {\n    return !!this.session\n  }\n\n  /**\n   * Sets a WhatWG \"fetch()\" function to be used for making HTTP requests.\n   */\n  setFetch(fetch = globalThis.fetch) {\n    this.fetch = fetch\n  }\n\n  async fetchHandler(url: string, init?: RequestInit): Promise<Response> {\n    // wait for any active session-refreshes to finish\n    await this.refreshSessionPromise\n\n    const initialUri = new URL(url, this.dispatchUrl)\n    const initialReq = new Request(initialUri, init)\n\n    const initialToken = this.session?.accessJwt\n    if (!initialToken || initialReq.headers.has('authorization')) {\n      return (0, this.fetch)(initialReq)\n    }\n\n    initialReq.headers.set('authorization', `Bearer ${initialToken}`)\n    const initialRes = await (0, this.fetch)(initialReq)\n\n    if (!this.session?.refreshJwt) {\n      return initialRes\n    }\n    const isExpiredToken =\n      initialRes.status === 401 ||\n      (await isErrorResponse(initialRes, [400], ['ExpiredToken']))\n\n    if (!isExpiredToken) {\n      return initialRes\n    }\n\n    try {\n      await this.refreshSession()\n    } catch {\n      return initialRes\n    }\n\n    if (init?.signal?.aborted) {\n      return initialRes\n    }\n\n    // The stream was already consumed. We cannot retry the request. A solution\n    // would be to tee() the input stream but that would bufferize the entire\n    // stream in memory which can lead to memory starvation. Instead, we will\n    // return the original response and let the calling code handle retries.\n    if (ReadableStream && init?.body instanceof ReadableStream) {\n      return initialRes\n    }\n\n    // Return initial \"ExpiredToken\" response if the session was not refreshed.\n    const updatedToken = this.session?.accessJwt\n    if (!updatedToken || updatedToken === initialToken) {\n      return initialRes\n    }\n\n    // Make sure the initial request is cancelled to avoid leaking resources\n    // (NodeJS ðŸ‘€): https://undici.nodejs.org/#/?id=garbage-collection\n    await initialRes.body?.cancel()\n\n    // We need to re-compute the URI in case the PDS endpoint has changed\n    const updatedUri = new URL(url, this.dispatchUrl)\n    const updatedReq = new Request(updatedUri, init)\n\n    updatedReq.headers.set('authorization', `Bearer ${updatedToken}`)\n\n    return await (0, this.fetch)(updatedReq)\n  }\n\n  /**\n   * Create a new account and hydrate its session in this agent.\n   */\n  async createAccount(\n    data: ComAtprotoServerCreateAccount.InputSchema,\n    opts?: ComAtprotoServerCreateAccount.CallOptions,\n  ): Promise<ComAtprotoServerCreateAccount.Response> {\n    // Clear any existing session\n    this.session = undefined\n    this.refreshSessionPromise = undefined\n\n    try {\n      const res = await this.server.createAccount(data, opts)\n      this.session = {\n        accessJwt: res.data.accessJwt,\n        refreshJwt: res.data.refreshJwt,\n        handle: res.data.handle,\n        did: res.data.did,\n        email: data.email,\n        emailConfirmed: false,\n        emailAuthFactor: false,\n        active: true,\n      }\n      this.persistSession?.('create', this.session)\n      this._updateApiEndpoint(res.data.didDoc)\n      return res\n    } catch (e) {\n      this.session = undefined\n      this.persistSession?.('create-failed', undefined)\n      throw e\n    }\n  }\n\n  /**\n   * Start a new session with this agent.\n   */\n  async login(\n    opts: AtpAgentLoginOpts,\n  ): Promise<ComAtprotoServerCreateSession.Response> {\n    // Clear any existing session\n    this.session = undefined\n    this.refreshSessionPromise = undefined\n\n    try {\n      const res = await this.server.createSession({\n        identifier: opts.identifier,\n        password: opts.password,\n        authFactorToken: opts.authFactorToken,\n        allowTakendown: opts.allowTakendown,\n      })\n\n      if (this.session) {\n        throw new Error('Concurrent login detected')\n      }\n\n      this.session = {\n        accessJwt: res.data.accessJwt,\n        refreshJwt: res.data.refreshJwt,\n        handle: res.data.handle,\n        did: res.data.did,\n        email: res.data.email,\n        emailConfirmed: res.data.emailConfirmed,\n        emailAuthFactor: res.data.emailAuthFactor,\n        active: res.data.active ?? true,\n        status: res.data.status,\n      }\n      this._updateApiEndpoint(res.data.didDoc)\n      this.persistSession?.('create', this.session)\n      return res\n    } catch (e) {\n      this.session = undefined\n      this.persistSession?.('create-failed', undefined)\n      throw e\n    }\n  }\n\n  async logout(): Promise<void> {\n    if (this.session) {\n      try {\n        await this.server.deleteSession(undefined, {\n          headers: {\n            authorization: `Bearer ${this.session.refreshJwt}`,\n          },\n        })\n      } catch {\n        // Ignore errors\n      } finally {\n        this.session = undefined\n        this.persistSession?.('expired', undefined)\n      }\n    }\n  }\n\n  /**\n   * Resume a pre-existing session with this agent.\n   *\n   * @note that a rejected promise from this method indicates a failure to\n   * refresh the session after resuming it but does not indicate a failure to\n   * set the session itself. In case of rejection, check the presence of\n   * {@link CredentialSession.session} after calling this method to ensure the\n   * session was set.\n   */\n  async resumeSession(\n    session: AtpSessionData,\n  ): Promise<\n    | ComAtprotoServerGetSession.Response\n    | ComAtprotoServerRefreshSession.Response\n  > {\n    // Protect against multiple calls to resumeSession that would trigger a\n    // refresh for the same session simultaneously.\n    // Ideally, this check would be based on a session identifier, but since\n    // we don't have one, we will just check the refresh token.\n    if (session.refreshJwt === this.session?.refreshJwt) {\n      // Protect against refreshes in progress\n      await this.refreshSessionPromise\n\n      // Another concurrent operation may have replaced the session while we\n      // were waiting for the refresh to complete.\n      if (session.did !== this.session?.did) {\n        throw new Error('DID mismatch on resumeSession')\n      }\n\n      return this.server.getSession(undefined, {\n        headers: { authorization: `Bearer ${this.session.accessJwt}` },\n      })\n    }\n\n    // Set the current session, then force a refresh, replacing any pending\n    // refresh operation.\n    this.session = session\n    this.refreshSessionPromise = undefined\n\n    const promise = this._refreshSessionInner()\n\n    // Discard any concurrent refresh, replacing it with this one.\n    this.refreshSessionPromise = promise\n      .then(\n        (): void => {},\n        (): void => {},\n      )\n      .finally(() => {\n        this.refreshSessionPromise = undefined\n      })\n\n    return promise\n  }\n\n  /**\n   * Internal helper to refresh sessions\n   * - Wraps the actual implementation in a promise-guard to ensure only\n   *   one refresh is attempted at a time.\n   */\n  async refreshSession(): Promise<void> {\n    if (!this.session) return\n\n    // Do not refresh if we already have a refresh in progress\n    return (this.refreshSessionPromise ||= this._refreshSessionInner()\n      .then(\n        (): void => {},\n        (): void => {},\n      )\n      .finally(() => {\n        this.refreshSessionPromise = undefined\n      }))\n  }\n\n  /**\n   * Internal helper to refresh sessions (actual behavior)\n   */\n  private async _refreshSessionInner(): Promise<ComAtprotoServerRefreshSession.Response> {\n    const { session } = this\n\n    // Should never happen\n    if (!session) throw new Error('No session to refresh')\n\n    try {\n      const res = await this.server.refreshSession(undefined, {\n        headers: { authorization: `Bearer ${session.refreshJwt}` },\n      })\n\n      const { data } = res\n\n      // Something is very wrong if the DID changes during a refresh\n      if (data.did !== session.did) {\n        throw new XRPCError(\n          ResponseType.InvalidRequest,\n          'Invalid session',\n          'InvalidDID',\n        )\n      }\n\n      // Historically, refreshSession did not return all the fields from\n      // getSession. In particular, email, emailConfirmed and emailAuthFactor\n      // were missing. Similarly, some servers might not return the didDoc in\n      // refreshSession. We fetch them via getSession if missing, allowing to\n      // ensure that we are always talking with the right PDS.\n      if (data.emailConfirmed == null || data.didDoc == null) {\n        try {\n          const res = await this.server.getSession(undefined, {\n            headers: { authorization: `Bearer ${data.accessJwt}` },\n          })\n\n          // Fool proofing (should always match)\n          if (res.data.did === data.did) {\n            Object.assign(data, res.data)\n          }\n        } catch {\n          // Noop, we'll keep the current values we have\n        }\n      }\n\n      // protect against concurrent session updates\n      if (this.session !== session) {\n        return Promise.reject(new Error('Concurrent session update detected'))\n      }\n\n      // succeeded, update the session\n      this.session = {\n        did: data.did,\n        accessJwt: data.accessJwt,\n        refreshJwt: data.refreshJwt,\n        handle: data.handle ?? session.handle,\n        email: data.email ?? session.email,\n        emailConfirmed: data.emailConfirmed ?? session.emailConfirmed,\n        emailAuthFactor: data.emailAuthFactor ?? session.emailAuthFactor,\n        active: data.active ?? session.active ?? true,\n        status: data.status ?? session.status,\n      }\n\n      this._updateApiEndpoint(res.data.didDoc)\n      this.persistSession?.('update', this.session)\n\n      return res\n    } catch (err) {\n      // protect against concurrent session updates\n      if (this.session === session) {\n        if (\n          err instanceof XRPCError &&\n          (err.status === 401 ||\n            err.error === 'InvalidDID' ||\n            ['ExpiredToken', 'InvalidToken'].includes(err.error))\n        ) {\n          // failed due to a bad refresh token\n          this.session = undefined\n          this.persistSession?.('expired', undefined)\n        } else {\n          // Assume the problem is transient and the session can be reused later.\n          this.session = session\n          this.persistSession?.('network-error', session)\n        }\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Helper to update the pds endpoint dynamically.\n   *\n   * The session methods (create, resume, refresh) may respond with the user's\n   * did document which contains the user's canonical PDS endpoint. That endpoint\n   * may differ from the endpoint used to contact the server. We capture that\n   * PDS endpoint and update the client to use that given endpoint for future\n   * requests. (This helps ensure smooth migrations between PDSes, especially\n   * when the PDSes are operated by a single org.)\n   */\n  private _updateApiEndpoint(didDoc: unknown) {\n    const endpoint = isValidDidDoc(didDoc) ? getPdsEndpoint(didDoc) : undefined\n    if (endpoint) {\n      this.pdsUrl = new URL(endpoint)\n    } else {\n      // If the did doc is invalid (or missing), we clear the pdsUrl (should\n      // never happen). This is fine if the auth server and PDS are the same\n      // service, or if the auth server will proxy requests to the right PDS\n      // (which is the case for Bluesky's \"entryway\").\n      this.pdsUrl = undefined\n    }\n  }\n}\n\nfunction isErrorObject(v: unknown): v is ErrorResponseBody {\n  return errorResponseBody.safeParse(v).success\n}\n\nasync function isErrorResponse(\n  response: Response,\n  status: number[],\n  errorNames: string[],\n): Promise<boolean> {\n  if (!status.includes(response.status)) return false\n  // Some engines (react-native ðŸ‘€) don't expose a response.body property...\n  // if (!response.body) return false\n  try {\n    const json = await peekJson(response, 10 * 1024)\n    return isErrorObject(json) && (errorNames as any[]).includes(json.error)\n  } catch (err) {\n    return false\n  }\n}\n\nasync function peekJson(\n  response: Response,\n  maxSize = Infinity,\n): Promise<unknown> {\n  if (extractType(response) !== 'application/json') throw new Error('Not JSON')\n  if (extractLength(response) > maxSize) throw new Error('Response too large')\n  return response.clone().json()\n}\n\nfunction extractLength({ headers }: Response) {\n  return headers.get('Content-Length')\n    ? Number(headers.get('Content-Length'))\n    : NaN\n}\n\nfunction extractType({ headers }: Response) {\n  return headers.get('Content-Type')?.split(';')[0]?.trim()\n}\n"]}