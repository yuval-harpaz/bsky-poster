{"version":3,"file":"defs.js","sourceRoot":"","sources":["../../../../../../src/client/types/app/bsky/contact/defs.ts"],"names":[],"mappings":";;AA2BA,wDAEC;AAED,oEAEC;AAYD,oCAEC;AAED,gDAEC;AAaD,wCAEC;AAED,oDAEC;AAjED,mDAA4D;AAC5D,2CAIyB;AAGzB,MAAM,QAAQ,GAAG,eAAS,EACxB,QAAQ,GAAG,mBAAS,CAAA;AACtB,MAAM,EAAE,GAAG,uBAAuB,CAAA;AAUlC,MAAM,wBAAwB,GAAG,sBAAsB,CAAA;AAEvD,SAAgB,sBAAsB,CAAI,CAAI;IAC5C,OAAO,QAAQ,CAAC,CAAC,EAAE,EAAE,EAAE,wBAAwB,CAAC,CAAA;AAClD,CAAC;AAED,SAAgB,4BAA4B,CAAI,CAAI;IAClD,OAAO,QAAQ,CAA2B,CAAC,EAAE,EAAE,EAAE,wBAAwB,CAAC,CAAA;AAC5E,CAAC;AAUD,MAAM,cAAc,GAAG,YAAY,CAAA;AAEnC,SAAgB,YAAY,CAAI,CAAI;IAClC,OAAO,QAAQ,CAAC,CAAC,EAAE,EAAE,EAAE,cAAc,CAAC,CAAA;AACxC,CAAC;AAED,SAAgB,kBAAkB,CAAI,CAAI;IACxC,OAAO,QAAQ,CAAiB,CAAC,EAAE,EAAE,EAAE,cAAc,CAAC,CAAA;AACxD,CAAC;AAWD,MAAM,gBAAgB,GAAG,cAAc,CAAA;AAEvC,SAAgB,cAAc,CAAI,CAAI;IACpC,OAAO,QAAQ,CAAC,CAAC,EAAE,EAAE,EAAE,gBAAgB,CAAC,CAAA;AAC1C,CAAC;AAED,SAAgB,oBAAoB,CAAI,CAAI;IAC1C,OAAO,QAAQ,CAAmB,CAAC,EAAE,EAAE,EAAE,gBAAgB,CAAC,CAAA;AAC5D,CAAC","sourcesContent":["/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\nimport type * as AppBskyActorDefs from '../actor/defs.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'app.bsky.contact.defs'\n\n/** Associates a profile with the positional index of the contact import input in the call to `app.bsky.contact.importContacts`, so clients can know which phone caused a particular match. */\nexport interface MatchAndContactIndex {\n  $type?: 'app.bsky.contact.defs#matchAndContactIndex'\n  match: AppBskyActorDefs.ProfileView\n  /** The index of this match in the import contact input. */\n  contactIndex: number\n}\n\nconst hashMatchAndContactIndex = 'matchAndContactIndex'\n\nexport function isMatchAndContactIndex<V>(v: V) {\n  return is$typed(v, id, hashMatchAndContactIndex)\n}\n\nexport function validateMatchAndContactIndex<V>(v: V) {\n  return validate<MatchAndContactIndex & V>(v, id, hashMatchAndContactIndex)\n}\n\nexport interface SyncStatus {\n  $type?: 'app.bsky.contact.defs#syncStatus'\n  /** Last date when contacts where imported. */\n  syncedAt: string\n  /** Number of existing contact matches resulting of the user imports and of their imported contacts having imported the user. Matches stop being counted when the user either follows the matched contact or dismisses the match. */\n  matchesCount: number\n}\n\nconst hashSyncStatus = 'syncStatus'\n\nexport function isSyncStatus<V>(v: V) {\n  return is$typed(v, id, hashSyncStatus)\n}\n\nexport function validateSyncStatus<V>(v: V) {\n  return validate<SyncStatus & V>(v, id, hashSyncStatus)\n}\n\n/** A stash object to be sent via bsync representing a notification to be created. */\nexport interface Notification {\n  $type?: 'app.bsky.contact.defs#notification'\n  /** The DID of who this notification comes from. */\n  from: string\n  /** The DID of who this notification should go to. */\n  to: string\n}\n\nconst hashNotification = 'notification'\n\nexport function isNotification<V>(v: V) {\n  return is$typed(v, id, hashNotification)\n}\n\nexport function validateNotification<V>(v: V) {\n  return validate<Notification & V>(v, id, hashNotification)\n}\n"]}