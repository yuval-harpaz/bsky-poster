{"version":3,"file":"bytes.js","sourceRoot":"","sources":["../src/bytes.ts"],"names":[],"mappings":";;AAGA,sCAkBC;AAED,wCAEC;AAzBD,gDAAwD;AAGxD,SAAgB,aAAa,CAAC,KAE7B;IACC,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC,QAAQ,IAAI,KAAK,CAAC,EAAE,CAAC;QACnC,OAAO,SAAS,CAAA;IAClB,CAAC;IAED,KAAK,MAAM,GAAG,IAAI,KAAK,EAAE,CAAC;QACxB,IAAI,GAAG,KAAK,QAAQ,EAAE,CAAC;YACrB,OAAO,SAAS,CAAA;QAClB,CAAC;IACH,CAAC;IAED,IAAI,OAAO,KAAK,CAAC,MAAM,KAAK,QAAQ,EAAE,CAAC;QACrC,MAAM,IAAI,SAAS,CAAC,wCAAwC,CAAC,CAAA;IAC/D,CAAC;IAED,OAAO,IAAA,qBAAU,EAAC,KAAK,CAAC,MAAM,CAAC,CAAA;AACjC,CAAC;AAED,SAAgB,cAAc,CAAC,KAAiB;IAC9C,OAAO,EAAE,MAAM,EAAE,IAAA,mBAAQ,EAAC,KAAK,CAAC,EAAE,CAAA;AACpC,CAAC","sourcesContent":["import { fromBase64, toBase64 } from '@atproto/lex-data'\nimport { JsonValue } from './json.js'\n\nexport function parseLexBytes(input?: {\n  $bytes?: unknown\n}): Uint8Array | undefined {\n  if (!input || !('$bytes' in input)) {\n    return undefined\n  }\n\n  for (const key in input) {\n    if (key !== '$bytes') {\n      return undefined\n    }\n  }\n\n  if (typeof input.$bytes !== 'string') {\n    throw new TypeError('$bytes must be a base64-encoded string')\n  }\n\n  return fromBase64(input.$bytes)\n}\n\nexport function encodeLexBytes(bytes: Uint8Array): JsonValue {\n  return { $bytes: toBase64(bytes) }\n}\n"]}